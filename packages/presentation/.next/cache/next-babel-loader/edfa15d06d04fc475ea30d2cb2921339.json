{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nclass Observer {\n  constructor(emitter) {\n    _defineProperty(this, \"subscriptions\", new Set());\n\n    _defineProperty(this, \"queue\", []);\n\n    _defineProperty(this, \"emitter\", void 0);\n\n    this.next = this.next.bind(this);\n    this.error = this.error.bind(this);\n    this.emitter = emitter;\n  }\n\n  next(data) {\n    if (this.subscriptions.size) {\n      this.subscriptions.forEach(callback => {\n        callback(data);\n      });\n    } else {\n      this.queue.push(data);\n    }\n  }\n\n  error(error) {\n    console.error(error);\n  }\n\n  subscribe(callback) {\n    this.subscriptions.add(callback);\n\n    if (this.queue.length) {\n      this.queue.forEach(data => callback(data));\n      this.queue = [];\n    }\n\n    if (this.subscriptions.size === 1) {\n      this.emitter(this.next, this.error);\n    }\n\n    return () => {\n      this.subscriptions.delete(callback);\n    };\n  }\n\n}\n\nexport { Observer };","map":{"version":3,"sources":["/Users/daniel.nakamashi/Documents/projects/clean-flashcards/node_modules/@flashcards/client/src/service/Observer.ts"],"names":["Observer","constructor","emitter","Set","next","bind","error","data","subscriptions","size","forEach","callback","queue","push","console","subscribe","add","length","delete"],"mappings":";;AAEA,MAAMA,QAAN,CAA2C;AAKzCC,EAAAA,WAAW,CAACC,OAAD,EAA+E;AAAA,2CAJzC,IAAIC,GAAJ,EAIyC;;AAAA,mCAHpD,EAGoD;;AAAA;;AACxF,SAAKC,IAAL,GAAY,KAAKA,IAAL,CAAUC,IAAV,CAAe,IAAf,CAAZ;AACA,SAAKC,KAAL,GAAa,KAAKA,KAAL,CAAWD,IAAX,CAAgB,IAAhB,CAAb;AACA,SAAKH,OAAL,GAAeA,OAAf;AACD;;AAEOE,EAAAA,IAAR,CAAaG,IAAb,EAA6B;AAC3B,QAAI,KAAKC,aAAL,CAAmBC,IAAvB,EAA6B;AAC3B,WAAKD,aAAL,CAAmBE,OAAnB,CAA2BC,QAAQ,IAAI;AACrCA,QAAAA,QAAQ,CAACJ,IAAD,CAAR;AACD,OAFD;AAGD,KAJD,MAIO;AACL,WAAKK,KAAL,CAAWC,IAAX,CAAgBN,IAAhB;AACD;AACF;;AAEOD,EAAAA,KAAR,CAAcA,KAAd,EAAoC;AAClCQ,IAAAA,OAAO,CAACR,KAAR,CAAcA,KAAd;AACD;;AAEDS,EAAAA,SAAS,CAACJ,QAAD,EAA2C;AAClD,SAAKH,aAAL,CAAmBQ,GAAnB,CAAuBL,QAAvB;;AAEA,QAAI,KAAKC,KAAL,CAAWK,MAAf,EAAuB;AACrB,WAAKL,KAAL,CAAWF,OAAX,CAAmBH,IAAI,IAAII,QAAQ,CAACJ,IAAD,CAAnC;AACA,WAAKK,KAAL,GAAa,EAAb;AACD;;AAED,QAAI,KAAKJ,aAAL,CAAmBC,IAAnB,KAA4B,CAAhC,EAAmC;AACjC,WAAKP,OAAL,CAAa,KAAKE,IAAlB,EAAwB,KAAKE,KAA7B;AACD;;AAED,WAAO,MAAM;AACX,WAAKE,aAAL,CAAmBU,MAAnB,CAA0BP,QAA1B;AACD,KAFD;AAGD;;AAxCwC;;AA2C3C,SAASX,QAAT","sourcesContent":["import { Observable } from '../usecase/protocols'\n\nclass Observer<T> implements Observable<T> {\n  private subscriptions: Set<(data?: T) => void> = new Set()\n  private queue: Array<T | undefined> = []\n  private emitter: (next: (data?: T) => void, error: (error: unknown) => void) => void\n\n  constructor(emitter: (next: (data?: T) => void, error: (error: unknown) => void) => void) {\n    this.next = this.next.bind(this)\n    this.error = this.error.bind(this)\n    this.emitter = emitter\n  }\n\n  private next(data?: T): void {\n    if (this.subscriptions.size) {\n      this.subscriptions.forEach(callback => {\n        callback(data)\n      })\n    } else {\n      this.queue.push(data)\n    }\n  }\n\n  private error(error: unknown): void {\n    console.error(error)\n  }\n\n  subscribe(callback: (data?: T) => void): () => void {\n    this.subscriptions.add(callback)\n\n    if (this.queue.length) {\n      this.queue.forEach(data => callback(data))\n      this.queue = []\n    }\n\n    if (this.subscriptions.size === 1) {\n      this.emitter(this.next, this.error)\n    }\n\n    return () => {\n      this.subscriptions.delete(callback)\n    }\n  }\n}\n\nexport { Observer }\n"]},"metadata":{},"sourceType":"module"}